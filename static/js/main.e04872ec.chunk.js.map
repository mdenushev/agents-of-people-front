{"version":3,"sources":["analyzer/index.ts","analyzer/tokens.ts","App.tsx","index.tsx"],"names":["RecordType","RecordReason","stemmer","require","makeToken","text","split","map","token","str","toLowerCase","setCurrent","stem","getCurrent","join","getTokensFromRecord","record","res","aliases","forEach","alias","push","reasonTypeText","Analyzer","records","tokens","this","firstOccurrence","matches","matchesMap","recordsMap","Object","entries","matchAll","RegExp","tokenMatch","index","matchKey","toString","length","console","log","full_name","undefined","end","start","sort","a","b","dataUrl","insertInString","part","position","slice","App","useState","analyzer","setAnalyzer","setLoading","axios","get","data","useEffect","loadData","setMatches","textChangedFlag","setTextChangedFlag","inputText","setInputText","loading","className","role","hidden","type","onClick","newMatches","FindMatches","element","document","getElementById","innerHTML","offset","match","highlightMatches","placeholder","onInput","e","currentTarget","value","id","m","i","Organization","r","reason","date","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.e04872ec.chunk.js","sourcesContent":["import {getTokensFromRecord} from \"./tokens\";\n\nexport enum RecordType {\n  Person = \"person\",\n  Organization = \"organization\"\n}\n\nexport enum RecordReason {\n  ForeignAgent = \"foreign_agent\",\n  Extremist = \"extremist\",\n  Unwelcome = \"unwelcome\"\n}\n\nexport const reasonTypeText = {\n  \"person:foreign_agent\": 'признан(а) иноагентом',\n  \"person:extremist\": 'признан(а) экстремистом',\n  \"organization:foreign_agent\": 'признано(а) организацией-иноагентом',\n  \"organization:extremist\": 'признано(а) экстремистской организацией',\n  \"organization:unwelcome\": 'признано(а) нежелательной организацией',\n}\n\nexport function getReasonByRecord(r: Record): string {\n  // @ts-ignore\n  return reasonTypeText[`${r.type}:${r.reason}`]\n}\n\nexport interface Record {\n  full_name: string;\n  reason: RecordReason\n  type: RecordType,\n  date: string,\n  aliases: string[],\n  description?: string\n}\n\nexport interface Match {\n  start: number,\n  end: number,\n  record: Record\n}\n\nexport class Analyzer {\n  tokens: { [token: string]: Record } = {}\n\n  constructor(records: Record[]) {\n    for (const record of records) {\n      for (const token of getTokensFromRecord(record)) {\n        this.tokens[token] = record;\n      }\n    }\n  }\n\n  FindMatches(text: string, firstOccurrence: boolean = false): Match[] {\n    let matches: Match[] = []\n    let matchesMap: { [matchKey: string]: boolean } = {}\n    let recordsMap: { [fullName: string]: boolean } = {}\n    text = ' ' + text // ugly hack, but match all won't work otherwise\n    for (const [token, record] of Object.entries(this.tokens)) {\n      for (const tokenMatch of text.matchAll(RegExp(token, 'gmi'))) {\n        if (tokenMatch.index && tokenMatch[0]) {\n          const matchKey = tokenMatch.index.toString() + \":\" + tokenMatch.index + tokenMatch[0].length;\n          console.log(tokenMatch[0], firstOccurrence, recordsMap[record.full_name], recordsMap, record)\n          if (\n            matchesMap[matchKey] !== undefined ||\n            (firstOccurrence && recordsMap[record.full_name] !== undefined)\n          ) continue;\n\n          matches.push({end: tokenMatch.index -1 + tokenMatch[0].length, start: tokenMatch.index -1, record});\n          matchesMap[matchKey] = true;\n          recordsMap[record.full_name] = true;\n        }\n      }\n    }\n    return matches.sort((a, b) => a.start - b.start)\n  }\n}\n\n","import {Record} from \"./index\";\nlet Snowball = require('snowball');\nlet stemmer = new Snowball('Russian')\nconst suffixRegexp = \"[а-яa-z']{0,2}\"\n\nexport function tokenize(text: string): string[] {\n  return text.split(/\\W+/).map(token => token.toLowerCase());\n}\nexport function stem(str: string) : string {\n  stemmer.setCurrent(str);\n  stemmer.stem();\n  return stemmer.getCurrent();\n}\n\nexport function makeToken(text: string): string {\n  return text.split(/[^a-zа-я]+/i).map(token => {\n    return stem(token.toLowerCase()) + suffixRegexp;\n  }).join(\"\\\\s+\")\n}\n\nexport function getTokensFromRecord(record: Record): string[] {\n  let res: string[]  = []\n  record.aliases.forEach(alias => {\n    res.push(makeToken(alias))\n  })\n  return res\n}\n","import React, {useEffect, useState} from 'react';\nimport './App.css';\nimport axios from 'axios';\nimport {Analyzer, getReasonByRecord, Match, RecordType} from \"./analyzer\";\n\nconst dataUrl = \"https://raw.githubusercontent.com/mdenushev/agent-of-people-data/master/foreign_agents.json\"\n\nfunction insertInString(text: string, part: string, position: number): string {\n  return [text.slice(0, position), part, text.slice(position)].join('')\n}\n\nfunction highlightMatches(text: string, matches: Match[]): string {\n  console.log(matches);\n  text = `<p class=\"result\">${text}</p>`;\n\n  let offset = 18\n  for (const match of matches) {\n    text = insertInString(text, '<span class=\"highlight\">', match.start + offset)\n    offset += 24\n    text = insertInString(text, '</span>', match.end + offset)\n    offset += 7\n  }\n  return text\n}\n\nfunction App() {\n  const [analyzer, setAnalyzer] = useState(new Analyzer([]))\n\n  async function loadData() {\n    setLoading(true);\n    let data = (await axios.get(dataUrl)).data\n    console.log(data);\n    // @ts-ignore\n    setAnalyzer(new Analyzer(data));\n    setLoading(false)\n  }\n\n  useEffect(() => {\n    loadData();\n  }, [])\n\n  let [matches, setMatches] = useState<Match[]>([])\n  let [textChangedFlag, setTextChangedFlag] = useState(false)\n  let [inputText, setInputText] = useState(\"\");\n  let [loading, setLoading] = useState(true);\n\n  function textChanged(e: React.FormEvent<HTMLTextAreaElement>) {\n    setInputText(e.currentTarget.value);\n    setTextChangedFlag(true);\n  }\n\n  function analyze() {\n    setLoading(true);\n    console.log(inputText)\n    let newMatches = analyzer.FindMatches(inputText, true)\n    setMatches(newMatches);\n    let element = document.getElementById(\"result-text\")\n    if (element !== null) {\n      element.innerHTML = highlightMatches(inputText, newMatches)\n    }\n\n    setLoading(false);\n    setTextChangedFlag(false);\n  }\n\n  return (\n    <div className=\"mt-5\">\n      <div className=\"spinner-border\" role=\"status\" hidden={!loading}>\n        <span className=\"visually-hidden\">Загрузка</span>\n      </div>\n      <div className=\"container\" hidden={loading}>\n        <div className=\"menu row mb-3\">\n          <div className=\"col\">\n            <button type=\"button\" className=\"btn btn-light\" onClick={analyze}>Анализировать</button>\n            {textChangedFlag ? <span>Текст изменился, нажмите кнопку \"Анализировать\"</span> : null}\n          </div>\n\n        </div>\n        <textarea className=\"text form-control row mb-3\" placeholder=\"Вставьте ваш текст\" onInput={textChanged}/>\n        <p id=\"result-text\" className=\"mx-3\"/>\n        {matches.length === 0 ? <p>В тексте не найдены упоминания иноагентов</p> :\n          <ul className=\"list-group list-group-flush\">\n            {matches.map((m, i) => <li key={i}\n                                       className=\"list-group-item\">{m.record.full_name}{m.record.type === RecordType.Organization && m.record.aliases.length !== 0 ? ` (${m.record.aliases[0]})` : null} {getReasonByRecord(m.record)} от {m.record.date}</li>)}\n          </ul>}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}